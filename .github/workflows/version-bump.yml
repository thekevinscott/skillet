name: Nightly Release

on:
  schedule:
    # Run at 2:00 AM UTC every day
    - cron: '0 2 * * *'
  workflow_dispatch:  # Allow manual trigger

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for new commits since last tag
        id: check
        run: |
          # Get the latest tag
          latest_tag=$(git tag --sort=-v:refname | grep -E '^v[0-9]' | head -n1)

          if [ -z "$latest_tag" ]; then
            echo "No tags found, will create initial release"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "compare_base=$(git rev-list --max-parents=0 HEAD)" >> $GITHUB_OUTPUT
            echo "current_version=0.0.0" >> $GITHUB_OUTPUT
          else
            # Check if there are commits since the last tag
            commits_since_tag=$(git rev-list ${latest_tag}..HEAD --count)
            if [ "$commits_since_tag" -gt 0 ]; then
              echo "Found $commits_since_tag commits since $latest_tag"
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "compare_base=$latest_tag" >> $GITHUB_OUTPUT
              # Extract version number from tag (remove 'v' prefix)
              echo "current_version=${latest_tag#v}" >> $GITHUB_OUTPUT
            else
              echo "No new commits since $latest_tag"
              echo "has_changes=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Determine version bump
        if: steps.check.outputs.has_changes == 'true'
        id: version
        run: |
          compare_base="${{ steps.check.outputs.compare_base }}"
          current="${{ steps.check.outputs.current_version }}"

          # Parse current version
          IFS='.' read -r major minor patch <<< "$current"

          # Analyze all commits since last tag to determine bump type
          # Check for breaking changes (highest priority)
          if git log --format=%B ${compare_base}..HEAD | grep -qiE '(BREAKING CHANGE|^[a-z]+!:)'; then
            echo "Detected: BREAKING CHANGE -> major bump"
            new_version="$((major + 1)).0.0"
          # Check for features
          elif git log --format=%B ${compare_base}..HEAD | grep -qE '^feat(\(.+\))?:'; then
            echo "Detected: feat commit -> minor bump"
            new_version="${major}.$((minor + 1)).0"
          # Default to patch
          else
            echo "Detected: fixes/chores only -> patch bump"
            new_version="${major}.${minor}.$((patch + 1))"
          fi

          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "New version will be: $new_version"

      - name: Check if tag exists on remote
        if: steps.check.outputs.has_changes == 'true'
        id: tag_check
        run: |
          if git ls-remote --tags origin | grep -q "refs/tags/v${{ steps.version.outputs.new_version }}$"; then
            echo "Tag v${{ steps.version.outputs.new_version }} already exists on remote, skipping"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create and push tag
        if: steps.check.outputs.has_changes == 'true' && steps.tag_check.outputs.exists == 'false'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "v${{ steps.version.outputs.new_version }}" -m "Release v${{ steps.version.outputs.new_version }}"
          git push origin "v${{ steps.version.outputs.new_version }}"
